source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

set _CHIPNAME stm32f0x
set _ENDIAN little
set _WORKAREASIZE 0x1000
set _FLASH_SIZE 0
set _CPUTAPID 0x0bb11477
set _TARGETNAME $_CHIPNAME.cpu
set _FLASHNAME $_CHIPNAME.flash

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

flash bank $_FLASHNAME stm32f1x 0x08000000 $_FLASH_SIZE 0 0 $_TARGETNAME

# adapter speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
adapter speed 100
adapter srst delay 100

reset_config srst_nogate

proc stm32f0x_default_reset_start {} {
    # Reset clock is HSI (8 MHz)
    adapter speed 1000
}

proc stm32f0x_default_examine_end {} {
    # Enable debug during low power modes (uses more power)
    mmw 0x40015804 0x00000006 0 ;# DBGMCU_CR |= DBG_STANDBY | DBG_STOP

    # Stop watchdog counters during halt
    mmw 0x40015808 0x00001800 0 ;# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
}

proc stm32f0x_default_reset_init {} {
    # Configure PLL to boost clock to HSI x 6 (48 MHz)
    mww 0x40021004 0x00100000   ;# RCC_CFGR = PLLMUL[2]
    mmw 0x40021000 0x01000000 0 ;# RCC_CR[31:16] |= PLLON
    mww 0x40022000 0x00000011   ;# FLASH_ACR = PRFTBE | LATENCY[0]
    sleep 10                    ;# Wait for PLL to lock
    mmw 0x40021004 0x00000002 0 ;# RCC_CFGR |= SW[1]

    # Boost JTAG frequency
    adapter speed 8000
}

proc uv_clear_flash_sector {sector_number} {
    echo [format "Eerasing sector 0x%02x = offset 0x%04x" [expr {$sector_number}]  [expr {$sector_number*512}]  ]
    write_memory 0x4006F000 32 {0x09}                           ;#set erasing mode
    write_memory 0x4006F004 32 [expr {$sector_number << 6}]
    write_memory 0x4006F01c 32 {0xAA}                           ;#unlock flash
    write_memory 0x4006F010 32 {0x01}                           ;#set OPSTART=1
    read_memory 0x4006F014 32 1                                 ;#check status for 0x02
    write_memory 0x4006F018 32 {0x55}                           ;#lock flash
}

proc uv_clear_whole_flash {} {
    for {set i 0} {$i < 0x100} {incr i} {
        uv_clear_flash_sector $i
    }
}


proc uv_flash_unlock {} {
    write_memory 0x4006F01c 32 {0xAA}     ;#unlock flash
}

proc uv_flash_lock {} {
    write_memory 0x4006F018 32 {0x55}     ;#lock flash
}


proc uv_flash_write {address value} {
    echo [format "Writing 0x%04x to address 0x%04x (FLASH_ADDR_REG=0x%04x)" $value $address [expr {($address>>2)+0xC000}]  ]
    write_memory 0x4006F000 32 {0x05}                          ;#set writing mode
    write_memory 0x4006F004 32 [expr {($address>>2)+0xC000}]   ;#set address in flash
    write_memory 0x4006F008 32 $value                          ;#set data
    write_memory 0x4006F010 32 {0x01}                          ;#set OPSTART=1
    read_memory 0x4006F014 32 1                                ;#check status for 0x04
}



# Default hooks
$_TARGETNAME configure -event examine-end { stm32f0x_default_examine_end }
$_TARGETNAME configure -event reset-start { stm32f0x_default_reset_start }
$_TARGETNAME configure -event reset-init { stm32f0x_default_reset_init }